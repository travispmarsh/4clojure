<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1483666263470">{:repl-history {:ide [], :local [&quot;(not (and true))&quot; &quot;(and (not (and true)) (or true))&quot; &quot;(doc reduce)&quot; &quot;(reduce (fn [v1 v2] (and (not (and v1 v2)) (or v1 v2))) true true)&quot; &quot;(and true false)&quot; &quot;(not (and true false))&quot; &quot;(or true false)&quot; &quot;(and (not (and true false)) (or true false))&quot; &quot;(and '(true true))&quot; &quot;((fn [&amp; args] (and (not (and args)) (or args))) false false)&quot; &quot;((fn [&amp; args] (and (not (and args)) (or args))) true true)&quot; &quot;((fn [&amp; args] (and (not (and args)) (or args))) true)&quot; &quot;((fn [&amp; args] (and (not (and args)) (or args))) true false)&quot; &quot;((fn [&amp; args] (doall\n                (println args)\n                (and (not (and args)) (or args))) true false))&quot; &quot;((fn [&amp; [args]] (doall\n                (println args)\n                (and (not (and args)) (or args))) true false))&quot; &quot;((fn [a b ] (doall\n                (println a b)\n                (and (not (and a b)) (or a b))) true false))&quot; &quot;((fn [a b] \n   (doall\n     (println (str a b))\n     (and (not (and a b)) (or a b))) true false))&quot; &quot;((fn [a b]\n   (doall\n     (prinln (str a b))\n     (and (not (and a b)) (or a b)))) true false)&quot; &quot;((fn [a b]\n   (doall\n     ;(prinln (str a b))\n     (and (not (and a b)) (or a b)))) true false)&quot; &quot;((fn [a b]\n   ;(prinln (str a b))\n   (and (not (and a b)) (or a b))) true false)&quot; &quot;((fn [a b]\n   ;(prinln (str a b))\n   (and (not (and a b)) (or a b))) true true)&quot; &quot;((fn [&amp; b]\n   ;(prinln (str a b))\n   (and (not (and b)) (or b))) true true)&quot; &quot;((fn [&amp; b]\n   ;(prinln (str a b))\n   (and (not (and b)) (or b))) true false)&quot; &quot;((fn [&amp; b]\n   (doall\n     (prinln b)\n     (and (not (and b)) (or b))  \n     )\n   ) true false)&quot; &quot;((fn [&amp; b]\n   (doall\n     (println b)\n     (and (not (and b)) (or b))  \n     )\n   ) true false)&quot; &quot;((fn [a b]\n   (doall\n     (println b)\n     (and (not (and a b)) (or a b))  \n     )\n   ) true false)&quot; &quot;((fn [a b]\n   (doall\n     (println (str b))\n     (and (not (and a b)) (or a b))\n     )\n   ) true false)&quot; &quot;((fn [a b]\n   (doall\n     ;(println (str b))\n     (and (not (and a b)) (or a b))\n     )\n   ) true false)&quot; &quot;((fn [a b]\n   ; (doall\n   ;(println (str b))\n   (and (not (and a b)) (or a b))\n   ;)\n   ) true false)&quot; &quot;(println (str true))&quot; &quot;((fn [a b]\n    (doall\n   (println (str b))\n   (and (not (and a b)) (or a b))\n   )\n   ) true false)&quot; &quot;((fn [a b]\n    (let [_ (println (str b))]\n      (and (not (and a b)) (or a b))\n   )\n   ) true false)&quot; &quot;((fn [a b]\n    (let [_ (println (str a))]\n      (and (not (and a b)) (or a b))\n   )\n   ) true false)&quot; &quot;(or '(true false))&quot; &quot;(and '(true false))&quot; &quot;(and *1 *2)&quot; &quot;((fn [&amp; b]\n    (let [_ (println (str b))]\n      (and (not (and b)) (or b))\n   )\n   ) true false)&quot; &quot;((fn [n s]\n   (conj\n     (list (mapcat conj (rest (partition n s))))\n     (first (partition n s)))) 3 [1 2 3 4 5 6])&quot; &quot;(mapcat [:a :b :c] [1 2 3])&quot; &quot;(apply cons [:a :b :c] [1 2 3])&quot; &quot;(map cons [:a :b :c] [1 2 3])&quot; &quot;(zipmap [:a :b :c] [1 2 3])&quot; &quot;(partition 2 *2)&quot; &quot;(partition-all *3)&quot; &quot;(partition-all *1)&quot; &quot;(partition-all 2 *2)&quot; &quot;(partition-all 2 *1)&quot; &quot;(interleave [:a :b :c] [1 2 3])&quot; &quot;(interleave  [1 2 3] [:a :b :c])&quot; &quot;(partition 2 *1)&quot; &quot;(keep-indexed *1)&quot; &quot;(doc filter)&quot; &quot;(doc keep-indexed)&quot; &quot;(keep-indexed *1 *1)&quot; &quot;(keep-indexed #(true? %) *1)&quot; &quot;(true? *1)&quot; &quot;(fn [set]\n  (map true? set))&quot; &quot;(map true? *1)&quot; &quot;(map #(not= nil? %) *1)&quot; &quot;(map #(nil? %) *1)&quot; &quot;(complement *1)&quot; &quot;(doc complement)&quot; &quot;(map #(complement nil? %) *1)&quot; &quot;(map #(complement (nil? %)) *2)&quot; &quot;(map #(complement (nil? %)) *1)&quot; &quot;(\n  (fn [set1 set2]\n   (map set1 set2))\n  #{0 1 2 3} #{2 3 4 5})&quot; &quot;(\n  (fn [set1 set2]\n    (some? (map set1 set2)))\n  #{0 1 2 3} #{2 3 4 5})&quot; &quot;(\n  (fn [set1 set2]\n    (map some? (map set1 set2)))\n  #{0 1 2 3} #{2 3 4 5})&quot; &quot;(keep-indexed\n  (fn [set] (map #(some? %) set))\n  *1)&quot; &quot;(map vector [:a :b :c] [1 2 3])&quot; &quot;(into {} *1)&quot; &quot;(intro {} (map vector [:a :b :c] [1 2 3]))&quot; &quot;(into {} (map vector [:a :b :c] [1 2 3]))&quot; &quot;((fn [set1 set2]\n   (into {} (map vector set1 set2)))\n  [:a :b :c] [1 2 3])&quot; &quot;(map #(some? %) *1)&quot; &quot;(\n  (fn [set1 set2]\n    (map set1 set2))\n  #{0 1 2 3} #{2 3 4 5})&quot; &quot;(filter *1 *1)&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (doall\n      (println a)\n      (println b)\n      (recur b (mod a b)))))&quot; &quot;(doc doall)&quot; &quot;(doc do)&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n        (println a)\n        (println b)\n        (recur b (mod a b)))))&quot; &quot;(doc str)&quot; &quot;(def myvar 1)&quot; &quot;(println (str \&quot;My Var is \&quot; myvar))&quot; &quot;(def myvar2 2)&quot; &quot;(println (str \&quot;My Var is \&quot; myvar \&quot; and MyVar2 is \&quot; myvar2))&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n      (println a)\n      (println b)\n      (recur b (mod a b))))\n  )&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n      (println (str \&quot;A \&quot; a))\n      (println b)\n      (recur b (mod a b))))\n  )&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n      (println (str \&quot;A \&quot; a str \&quot;B \&quot; b))\n      (recur b (mod a b))))\n  )&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n      (println (str \&quot;A \&quot; a \&quot;B \&quot; b))\n      (recur b (mod a b))))\n  )&quot; &quot;(defn gcd [a b]\n  (if (zero? b)\n    a\n    (do\n      (println (str \&quot;A \&quot; a \&quot;   B \&quot; b))\n      (recur b (mod a b))))\n  )&quot; &quot;(gcd 1023 858)&quot; &quot;(mod 858 165)&quot; &quot;(mod 48 18)&quot; &quot;(mod 18 12)&quot; &quot;(mod 12 6)&quot; &quot;(gcd 48 18)&quot; &quot;(take 5 (iterate inc 1))&quot; &quot;(take 5 \n      ((fn [myfunc seed]\n         (myfunc seed)) \n        inc 1))&quot; &quot;(take 5\n      ((fn [myfunc seed]\n         (partial myfunc seed))\n        inc 1))&quot;], :remote []}}</component>
</project>